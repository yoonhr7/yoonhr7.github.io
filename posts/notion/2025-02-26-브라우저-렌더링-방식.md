---
title: "브라우저 렌더링 방식"
date: "2025-02-26"
tags: ["etc.."]
notionId: "1a6a784e-4dc2-80a0-8434-ec00384eaff8"
lastEditedTime: "2026-01-10T04:21:00.000Z"
---
<aside data-icon="💡">

CSS width: 1px; vs border: 1px solid; 렌더링 차이점

</aside>


### `width: 1px;`이 화면 크기에 따라 두께가 변하는 이유


`width`는 요소의 **컨텐츠 박스(content box)** 크기를 결정하는 속성이야. 하지만 브라우저가 실제 화면에 그릴 때는 **서브픽셀(subpixel) 연산**을 사용해서 조정합니다.

1. 브라우저는 CSS에서 지정한 `width` 값을 **레이아웃 단계(layout phase)**에서 계산합니다.
2. `width: 1px;`처럼 작은 값은 **화면 해상도(density)와 스케일 비율(device pixel ratio, DPR)**에 따라 **서브픽셀 단위로 변환**될 수 있습니다.
3. `width: 1px;`이지만, DPR이 2인 경우(예: 레티나 디스플레이) 실제 화면에서는 `2px` 단위로 그려질 수도 있고, 브라우저가 **안티앨리어싱(anti-aliasing) 처리**를 적용해서 흐릿하거나 두껍게 보일 수도 있습니다.

🔹 **서브픽셀(subpixel) 연산이 적용되는 이유**

- 대부분의 브라우저는 **서브픽셀 정렬(subpixel positioning)**을 지원해서, `1px` 미만의 값도 소수점까지 계산하려고 합니다.
- 예를 들어, `width: 1px;`이지만 브라우저 계산 결과 `0.8px`이 되면, 이를 반올림하면서 렌더링할 수도 있고, 안티앨리어싱을 적용해서 흐릿하게 보이게 할 수도 있습니다.
- 특히 화면 크기를 조정할 때(`transform: scale();` 등), 서브픽셀 연산 결과가 계속 달라질 수 있어서 너비가 미세하게 변합니다.

### `border: 1px solid;`가 일정한 이유


반면, `border`는 **레이어(layer) 개념으로 독립적인 페인팅 단계에서 처리**되기 때문에 서브픽셀 연산이 거의 적용되지 않습니다.

1. 브라우저는 `border: 1px solid;`을 만나면, 요소의 박스 모델에서 **보더 영역(border box)**을 별도로 계산합니다.
2. 보더는 일반적으로 **픽셀 정렬(pixel snapping)**을 적용해서 **화면 픽셀(grid)에 딱 맞게** 배치하려고 합니다.
3. 이 과정에서 **서브픽셀 정렬이 거의 발생하지 않기 때문에 항상 일정한 두께(1px)**로 유지됩니다.
4. 또한, 대부분의 브라우저는 `border`를 **페인팅 단계(paint phase)**에서 직접 그리기 때문에, `width`보다 더 안정적인 픽셀 정렬을 보장합니다.

🔹 **픽셀 정렬(pixel snapping)이 적용되는 이유**

- `border`는 브라우저에서 "도형(geometry)"으로 인식되며, **독립적인 페인트 레이어에 렌더링**되기 때문에 픽셀 스냅(pixel snapping) 처리를 거쳐 **정확히 1px**로 표시됨.
- 안티앨리어싱이 적용될 수는 있지만, `width`처럼 서브픽셀 크기로 조정되지 않음.

### **브라우저 렌더링 파이프라인에서 차이점**


브라우저가 CSS를 해석해서 화면에 표시하는 과정은 대략 다음과 같습니다.


1️⃣ **스타일 계산(Style Calculation)**

- CSS 규칙을 해석하고 요소별 스타일을 계산합니다.
- `width: 1px;`이나 `border: 1px;`도 여기서 파싱됩니다.

2️⃣ **레이아웃(Layout)**

- 요소의 크기와 위치를 계산.
- `width: 1px;`은 이 과정에서 **서브픽셀 단위로 변환될 가능성**이 있습니다.
- `border: 1px;`은 이 단계에서 상대적으로 고정적인 크기를 가집니다.

3️⃣ **페인트(Painting)**

- 요소의 픽셀 데이터를 생성합니다.
- `border`는 이 단계에서 **픽셀 정렬이 적용**되므로 일정한 두께 유지합니다.
- `width`는 안티앨리어싱 적용 여부에 따라 미세한 차이가 생길 수도 있습니다.

4️⃣ **컴포지팅(Compositing)**

- 화면에 그려진 요소들을 합성하여 최종적으로 렌더링합니다.

🡆 이 과정에서 `width`는 레이아웃 단계에서 변동될 가능성이 있지만, `border`는 페인트 단계에서 일정한 픽셀 정렬을 유지하기 때문에 결과적으로 **보더가 더 안정적**이야.


### **픽셀과 서브픽셀(Subpixel)이란?**


우리가 흔히 말하는 "1px"은 CSS 단위야. 하지만 **디스플레이에서의 물리적인 픽셀(physical pixel)과는 다를 수 있습니다.**

- **CSS 픽셀(CSS pixel)**: 우리가 CSS에서 `width: 1px;`로 지정하는 논리적인 크기.
- **물리 픽셀(Physical pixel)**: 실제 디스플레이에서 빛을 발하는 최소 단위.
- **서브픽셀(Subpixel)**: 브라우저가 안티앨리어싱(anti-aliasing)이나 디스플레이의 해상도 차이를 보정하기 위해 픽셀보다 더 정밀하게 계산하는 개념.

### **왜** **`width: 1px;`****이 다르게 보일까?**


### (1) **디스플레이의 DPI와 Device Pixel Ratio (DPR) 때문**


모든 디스플레이가 같은 크기의 물리 픽셀을 가지고 있지 않기 때문에, 브라우저는 CSS 픽셀을 **장치의 해상도에 맞게 변환**해서 표시합니다.


예를 들어:

- 일반적인 모니터 (DPR = 1)
    - `width: 1px;` → **1 CSS 픽셀 = 1 물리 픽셀**
- 레티나 디스플레이 (DPR = 2)
    - `width: 1px;` → **1 CSS 픽셀 = 2×2개의 물리 픽셀**
    - 브라우저가 픽셀을 확장하면서 안티앨리어싱이 적용될 수 있음 → 결과적으로 두께가 달라 보일 수 있습니다.

👉 **DPR이 1이 아닐 경우, CSS 픽셀을 물리 픽셀로 변환하면서 보이는 두께가 달라질 수 있음.**


### (2) **서브픽셀 렌더링과 반올림 문제**


브라우저는 CSS `width` 값을 소수점 단위까지 연산할 수 있습니다.


예를 들어, 요소의 크기를 계산할 때 `width: 1px;`을 지정했더라도, 화면 해상도나 DPR에 따라 **0.8px**이나 **1.3px** 같은 값으로 계산될 수 있습니다.


### 📌 예제 상황:

- 화면 크기 또는 줌 비율이 125%일 때
- 브라우저의 내부 계산에서 `width: 1px;`이 `0.8px`로 변환됨
- 물리 픽셀로 정렬되지 않아서 **픽셀 반올림(pixel rounding)** 이 적용됨
- 안티앨리어싱으로 인해 흐릿하거나 두껍게 보일 수 있음

👉 **브라우저는 서브픽셀(0.8px, 1.3px 등)을 처리하면서 최적화하는 과정에서 픽셀을 반올림하거나 안티앨리어싱을 적용하여 결과적으로 다르게 보이게 됩니다.**


### (3) **브라우저의 렌더링 방식 차이**


브라우저마다 픽셀을 처리하는 방식이 다를 수도 있습니다.


특히 크롬, 파이어폭스, 사파리 등은 각기 다른 **서브픽셀 정렬 방식과 안티앨리어싱 알고리즘**을 사용합니다.

- **크롬(Chrome)**: 서브픽셀을 활용하여 부드러운 가장자리 처리 → 1px이 흐려질 가능성 있습니다.
- **파이어폭스(Firefox)**: 픽셀 스냅(Pixel Snapping)을 적용해서 최대한 선명하게 표시합니다.
- **사파리(Safari)**: 레티나 디스플레이에서 픽셀을 보정하여 가독성을 높입니다.

👉 **같은** **`width: 1px;`****이라도 브라우저의 렌더링 엔진에 따라 결과가 다르게 보일 수 있습니다.**

