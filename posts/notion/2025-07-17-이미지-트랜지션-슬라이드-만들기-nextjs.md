---
title: "Ïù¥ÎØ∏ÏßÄ Ìä∏ÎûúÏßÄÏÖò Ïä¨ÎùºÏù¥Îìú ÎßåÎì§Í∏∞ (Next.js)"
date: "2025-07-17"
tags: ["JavaScript","animation","React"]
notionId: "233a784e-4dc2-80d8-ac9b-e56d544c03a1"
lastEditedTime: "2026-01-10T04:21:00.000Z"
---
<aside data-icon="üí°">

Next.js Î°ú Ï†úÏûëÎêú ÏΩîÎìú ÏûÖÎãàÎã§.

</aside>


## Î∞∞Í≤Ω Ïù¥ÎØ∏ÏßÄ Ìä∏ÎûúÏßÄÏÖò Ïä¨ÎùºÏù¥Îìú(autoplay, progressbar, navbar)


![transitionslide.gif](https://prod-files-secure.s3.us-west-2.amazonaws.com/65a7a4f3-5212-474e-9cb7-2dc73b477f61/ade5ee82-0a5e-4081-a54a-cbd337354e1f/transitionslide.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466TPPVKFQU%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T081855Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEPD%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIFi5hyTRxT7CPVA4tcKohuRbW4VYQzMLjTMDqP5Ccs5QAiBMo1bHu4ayb2tZV%2F%2BudC897JsTiVJB7N%2FNbqsHaSZMVyqIBAi5%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDYzNzQyMzE4MzgwNSIMzk5BkFyi2Tm9Eu3JKtwDaE49WHAJC3ZHAgPVKXDVD%2FTA6SxS%2Fnhg3Ym%2FZnm7MMAsI7AnDkSugW3Wf3x%2Bg7kt0j72mT9EAsHYa%2FNviSWcCDF5uaijuZAyS8gLPK1bI3oMnDdEGYC4%2FFo54mSPRWSipfA3HuQEYtTWywKijLn%2FRDJZy5w3zKMjNNN%2FyUhAfhEMZ%2FfV6IeaY2UhJp0x2OdcOQCXjuJ8U59v5jsQfvWUDomhzCL9RWMxOy9Q1alm9hBKiLfvunRSmXMUpQtPft9ULw5yb2r7uZimkEkXk99AQZIygrfJAmD4TFtqSpB2QwH020J5cooBRksvZMtttANiw19sFzwZiWz8XPA6FKyYh6SN4Afp%2FQOILVaCEnl5ReVpUFbbjS9QQPiSBn%2FSXKmPvAdu7cC4Gx5WBiMsoSwYz%2BeFtWCKULPkaFQ9I8QInZwpeRWqdfMKkI%2BRUM4sosELTHom6CeVwyHMo%2F%2FwZEqgIIXXKD%2Fe0fGmm3eMLRJFazTbqAB3ObOAnfwzvwzuotTAFe7xMoJbymOwE8B1ui9TB8MzPX%2FJ13lVYXJEqhxj2N3HNdmca76VnSlK4sK1mVmYRlCCQSLHarvuu7tobQXyetZv4U6SitStoZy6AmJTjVZlNQpUvVzAliSqoXcw9YyIywY6pgGcVKqipxGphrjIK27kNEZycZMO0xOSeMG6WoOaeK9iZpVfybI1HjO1vr%2F0AR32Z8gD1m8DZANDbkZwQ2eGV1VAEQxuO8ppBumzbyHBVSWix78yVvZ2N7t9xoRVt40bU9P4K2A6LaA5Ms7TVOS6QNAndRFscwuvW0k%2Fi1xBaGFBeWO6Oh3uKvMcMLOq7AyPulgLray9t8JAt%2BRhTsDScn8Z73ro9EGK&X-Amz-Signature=f6009463bbeec7030c4979cacf09a0800ddff1a5d6a975742deda744ee251213&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


### ‚óæ Ïª¥Ìè¨ÎÑåÌä∏ ÏÇ¨Ïö© ÏòàÏãú


```typescript
import Slider from "@/components/Slider/index";

export default function Home() {
		return (
        <div className="home">
            <Slider 
	            type="D" 
	            autoplay={{ interval: 5000, progressbar: "multi", controlButton: true }}
	          >
                <div className="slide">
                    <div className="slide-bg">
                        <img src="/img/testBg_01.jpg" />
                    </div>
                    <div className="slide-content">
                        <div>
                            <h1>Ï≤´ Î≤àÏß∏ Ïä¨ÎùºÏù¥Îìú</h1>
                            <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos.</p>
                        </div>
                    </div>
                </div>
                <div className="slide">
                    <div className="slide-bg">
                        <img src="/img/testBg_02.jpg" />
                    </div>
                    <div className="slide-content">
                        <div>
                            <h1>Îëê Î≤àÏß∏ Ïä¨ÎùºÏù¥Îìú</h1>
                            <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos.</p>
                        </div>
                    </div>
                </div>
                <div className="slide">
                    <div className="slide-bg">
                        <img src="/img/testBg_03.jpg" />
                    </div>
                    <div className="slide-content">
                        <div>
                            <h1>ÏÑ∏ Î≤àÏß∏ Ïä¨ÎùºÏù¥Îìú</h1>
                            <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos.</p>
                        </div>
                    </div>
                </div>
            </Slider>
        </div>
    )
}
```


### ‚óæ **Ïª¥Ìè¨ÎÑåÌä∏ ÏòµÏÖò** 


| ÏòµÏÖòÎ™Ö        | ÌÉÄÏûÖ                            | Í∏∞Î≥∏Í∞í     | ÏÑ§Î™Ö                   |
| ---------- | ----------------------------- | ------- | -------------------- |
| `type`     | `"A"` | `"B"` | `"C"` | `"D"` | (ÌïÑÏàò)    | WebGL Ï†ÑÌôò Ìö®Í≥º Ïú†Ìòï ÏÑ†ÌÉù    |
| `children` | `ReactNode`                   | (ÌïÑÏàò)    | Í∞Å Ïä¨ÎùºÏù¥Îìú ÏΩòÌÖêÏ∏† (DOM ÏöîÏÜå)  |
| `autoplay` | `boolean` ÎòêÎäî Í∞ùÏ≤¥               | `false` | ÏûêÎèô Ïû¨ÏÉù Ïó¨Î∂Ä ÎòêÎäî ÏÉÅÏÑ∏ ÏÑ§Ï†ï Í∞ùÏ≤¥ |


`autoplay` **ÏòµÏÖò ÏÑ∏Î∂Ä ÏÑ§Î™Ö**


| ÌïòÏúÑ ÏòµÏÖòÎ™Ö          | ÌÉÄÏûÖ                              | Í∏∞Î≥∏Í∞í     | ÏÑ§Î™Ö                               |
| --------------- | ------------------------------- | ------- | -------------------------------- |
| `interval`      | `number`                        | `4000`  | ÏûêÎèô Ï†ÑÌôò Í∞ÑÍ≤©(ms)                     |
| `progressbar`   | `"single"` | `"multi"` | `true` | `false` | ÏßÑÌñâÎ∞î Ïä§ÌÉÄÏùº (`true`Îäî `"single"`Î°ú Ï≤òÎ¶¨) |
| `controlButton` | `boolean`                       | `false` | Ïû¨ÏÉù/Ï†ïÏßÄ Î≤ÑÌäº ÌëúÏãú Ïó¨Î∂Ä                   |


**ÏòµÏÖò ÏÇ¨Ïö© ÏòàÏãú**


```typescript
<Slider
  type="A"
  autoplay={{
    interval: 6000,
    progressbar: "single",
    controlButton: true,
  }}
>
  <div className="slide">
      <div className="slide-bg">
          <img src="/img/testBg_03.jpg" />
      </div>
      <div className="slide-content">
          <!-- ÏΩòÌÖêÏ∏† ÎÇ¥Ïö© -->
      </div>
  </div>
  <div className="slide">
      <div className="slide-bg">
          <img src="/img/testBg_03.jpg" />
      </div>
      <div className="slide-content">
          <!-- ÏΩòÌÖêÏ∏† ÎÇ¥Ïö© -->
      </div>
  </div>
</Slider>
```

<details>
<summary>Slider Ïª¥Ìè¨ÎÑåÌä∏ ÏΩîÎìú</summary>

```typescript
// @/components/Slider/index.tsx

"use client";

import { ReactNode, useEffect, useRef, Children, isValidElement, cloneElement, useState } from "react";
import Sketch from "./Sketch";

type AutoplayOption =
    | boolean
    | {
          interval?: number; // Í∏∞Î≥∏: 4000 (ms)
          progressbar?: "single" | "multi" | true; // ÌïòÎÇòÏùò bar vs Ïó¨Îü¨ bar (Ïä¨ÎùºÏù¥Îìú Í∞úÏàò Í∏∞Ï§Ä), true = "single"
          controlButton?: boolean; // Ïû¨ÏÉù/Ï†ïÏßÄ Î≤ÑÌäº Ïó¨Î∂Ä
      };

const DEFAULT_INTERVAL = 4000;

type Props = {
    type: "A" | "B" | "C" | "D";
    children: ReactNode;
    autoplay?: AutoplayOption;
};

const sketchOptions: Record<
    "A" | "B" | "C" | "D",
    {
        fragment: string;
        uniforms: Record<string, { value: number; min?: number; max?: number; type: string }>;
        duration?: number;
        easing?: string;
        debug?: boolean;
    }
> = {
    A: {
        debug: false,
        uniforms: {
            intensity: { value: 50, type: "f", min: 1, max: 100 },
        },
        fragment: `
            uniform float time;
            uniform float progress;
            uniform float intensity;
            uniform float width;
            uniform float scaleX;
            uniform float scaleY;
            uniform float transition;
            uniform float radius;
            uniform float swipe;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform sampler2D displacement;
            uniform vec4 resolution;
            varying vec2 vUv;
            mat2 rotate(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, -s, s, c);
            }
            const float PI = 3.1415;
            const float angle1 = PI *0.25;
            const float angle2 = -PI *0.75;


            void main()	{
                vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

                vec2 uvDivided = fract(newUV*vec2(intensity,1.));


                vec2 uvDisplaced1 = newUV + rotate(3.1415926/4.)*uvDivided*progress*0.1;
                vec2 uvDisplaced2 = newUV + rotate(3.1415926/4.)*uvDivided*(1. - progress)*0.1;

                vec4 t1 = texture2D(texture1,uvDisplaced1);
                vec4 t2 = texture2D(texture2,uvDisplaced2);

                gl_FragColor = mix(t1, t2, progress);

            }

        `,
    },
    B: {
        uniforms: {
            width: { value: 0.5, min: 0, max: 10, type: "f" },
        },
        duration: 1.5,
        easing: "easeOut",
        debug: false,
        fragment: `
        uniform float time;
        uniform float progress;
        uniform sampler2D texture1;
        uniform sampler2D texture2;
        uniform vec4 resolution;

        varying vec2 vUv;
        varying vec4 vPosition;


        void main()	{
            vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
            vec2 p = newUV;
            float x = progress;
            x = smoothstep(.0,1.0,(x*2.0+p.y-1.0));
            vec4 f = mix(
                texture2D(texture1, (p-.5)*(1.-x)+.5), 
                texture2D(texture2, (p-.5)*x+.5), 
                x);
            gl_FragColor = f;
        }`,
    },
    C: {
        uniforms: {
            radius: { value: 0.9, min: 0.1, max: 2, type: "f" },
            width: { value: 0.35, min: 0, max: 1, type: "f" },
        },
        duration: 1.5,
        debug: false,
        easing: "easeOut",
        fragment: `
            uniform float time;
            uniform float progress;
            uniform float width;
            uniform float scaleX;
            uniform float scaleY;
            uniform float transition;
            uniform float radius;
            uniform float swipe;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform sampler2D displacement;
            uniform vec4 resolution;

            varying vec2 vUv;
            varying vec4 vPosition;

            float parabola( float x, float k ) {
            return pow( 4. * x * ( 1. - x ), k );
            }

            void main()	{
            vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
            vec2 p = newUV;
            vec2 start = vec2(0.5,0.5);
            vec2 aspect = resolution.wz;

            vec2 uv = newUV;
            float dt = parabola(progress, 1.);
            vec4 noise = texture2D(displacement, fract(vUv+time*0.04));
            float prog = progress*0.66 + noise.g * 0.04;
            float circ = 1. - smoothstep(-width, 0.0, radius * distance(start*aspect, uv*aspect) - prog*(1.+width));
            float intpl = pow(abs(circ), 1.);
            vec4 t1 = texture2D( texture1, (uv - 0.5) * (1.0 - intpl) + 0.5 ) ;
            vec4 t2 = texture2D( texture2, (uv - 0.5) * intpl + 0.5 );
            gl_FragColor = mix( t1, t2, intpl );
            }
        `,
    },
    D: {
        debug: false,
        uniforms: {
            intensity: { value: 0.3, type: "f", min: 0, max: 2 },
        },
        fragment: `
            uniform float time;
            uniform float progress;
            uniform float width;
            uniform float scaleX;
            uniform float scaleY;
            uniform float transition;
            uniform float radius;
            uniform float intensity;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform sampler2D displacement;
            uniform vec4 resolution;
            varying vec2 vUv;

            void main()	{
            vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

            vec4 d1 = texture2D(texture1, newUV);
            vec4 d2 = texture2D(texture2, newUV);

            float displace1 = (d1.r + d1.g + d1.b)*0.33;
            float displace2 = (d2.r + d2.g + d2.b)*0.33;
            
            vec4 t1 = texture2D(texture1, vec2(newUV.x, newUV.y + progress * (displace2 * intensity)));
            vec4 t2 = texture2D(texture2, vec2(newUV.x, newUV.y + (1.0 - progress) * (displace1 * intensity)));

            gl_FragColor = mix(t1, t2, progress);

            }
        `,
    },
};

export default function Slider({ type, children, autoplay = false }: Props) {
    const sliderRef = useRef<HTMLDivElement>(null);
    const sketchRef = useRef<Sketch | null>(null);
    const autoplayRef = useRef<NodeJS.Timeout | null>(null);
    const progressRefs = useRef<HTMLDivElement[]>([]);

    const [currentIndex, setCurrentIndex] = useState(0);

    // autoplay { interval, progressbar, controlButton }
    const isAutoPlayEnabled = autoplay !== false;

    const { interval = DEFAULT_INTERVAL, progressbar, controlButton } = typeof autoplay === "object" ? autoplay : {};

    const [isPlaying, setIsPlaying] = useState(isAutoPlayEnabled);

    const [progress, setProgress] = useState(0);
    const [progressRat, setProgressRat] = useState(0);
    const progressIntervalRef = useRef<NodeJS.Timeout | null>(null);
    const isProgressBarSingle = isAutoPlayEnabled && (progressbar === "single" || progressbar === true);
    const isProgressBarMulti = isAutoPlayEnabled && progressbar === "multi";

    const showStopButton = isAutoPlayEnabled && controlButton === true;

    // childrenÏóêÏÑú Ïù¥ÎØ∏ÏßÄ URLÎßå Ï∂îÏ∂ú
    const imageUrls = Children.toArray(children)
        .map((child: any) => {
            if (!isValidElement(child)) return null;

            const bg = Children.toArray(child.props.children).find((c: any) => isValidElement(c) && c.props.className?.includes("slide-bg"));

            if (!bg) return null;

            const img = Children.toArray(bg.props.children).find((c: any) => isValidElement(c) && c.type === "img");

            return img?.props?.src;
        })
        .filter(Boolean);

    useEffect(() => {
        if (!sliderRef.current || imageUrls.length === 0 || sketchRef.current) return;

        sliderRef.current.setAttribute("data-images", JSON.stringify(imageUrls));

        sketchRef.current = new Sketch({
            fragment: sketchOptions[type].fragment,
            uniforms: sketchOptions[type].uniforms,
            duration: sketchOptions[type].duration,
            easing: sketchOptions[type].easing,
            debug: sketchOptions[type].debug,
        });
    }, [type, imageUrls]);

    // autoplay control
    const startProgressBar = () => {
        if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);

        const step = 100 / (interval / 100); // 100ms Îã®ÏúÑÎ°ú ÎÇòÎà†ÏÑú Ï¶ùÍ∞Ä
        progressIntervalRef.current = setInterval(() => {
            setProgress((prev) => {
                const next = prev + step;
                if (next >= 100) {
                    clearInterval(progressIntervalRef.current!);
                    handleNext();
                    return 0;
                }
                return next;
            });
        }, 100);
    };

    const cancelProgressBar = () => {
        if (progressIntervalRef.current) {
            cancelAnimationFrame(progressIntervalRef.current);
            progressIntervalRef.current = null;
        }
        setProgress(progress);
    };
    useEffect(() => {
        if (isPlaying) {
            startProgressBar();
        }
        return () => {
            if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
        };
    }, [isPlaying]);

    const handleNext = () => {
        if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
        setProgress(0); // ÏßÑÌñâÎèÑ Ï¥àÍ∏∞Ìôî

        sketchRef.current?.next();
        setCurrentIndex((prev) => (prev + 1) % imageUrls.length);

        if (isPlaying) startProgressBar(); // ÏûêÎèôÏû¨ÏÉù Ï§ëÏù¥Î©¥ ÏßÑÌñâÎ∞î Îã§Ïãú ÏãúÏûë
    };

    const handlePrev = () => {
        if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
        setProgress(0); // ÏßÑÌñâÎèÑ Ï¥àÍ∏∞Ìôî

        sketchRef.current?.prev();
        setCurrentIndex((prev) => (prev - 1 + imageUrls.length) % imageUrls.length);

        if (isPlaying) startProgressBar(); // ÏûêÎèôÏû¨ÏÉù Ï§ëÏù¥Î©¥ ÏßÑÌñâÎ∞î Îã§Ïãú ÏãúÏûë
    };

    const handleAutoplay = () => {
        if (isPlaying) {
            // Ï†ïÏßÄ Î°úÏßÅ
            if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
            progressIntervalRef.current = null;
            setIsPlaying(false);
        } else {
            // Ïû¨ÏÉù Ïû¨Í∞ú
            setIsPlaying(true); // useEffectÏóêÏÑú startProgressBar ÏûêÎèô Ïã§Ìñâ
        }
    };

    return (
        <div className="slider-container">
            {/* WebGL Î∞∞Í≤Ω Ï∫îÎ≤ÑÏä§ */}
            <div id="slider" ref={sliderRef} className="slider-canvas" />

            {/* ÏΩòÌÖêÏ∏† Ïò§Î≤ÑÎ†àÏù¥ */}
            <div className="slide-content-wrapper">
                {Children.map(children, (child, i) =>
                    isValidElement(child)
                        ? cloneElement(child, {
                              className: [child.props.className, i === currentIndex ? "active" : ""].filter(Boolean).join(" "),
                          })
                        : child
                )}
            </div>
            {/* AutoPlay Stop Button */}
            {showStopButton && (
                <button className="stop-btn" onClick={handleAutoplay}>
                    {isPlaying ? "Pause" : "Play"}
                </button>
            )}
            {/* Progress Bar */}
            {isProgressBarSingle && (
                <div className="progress-bar-wrapper">
                    <div className="progress-bar">
                        <div
                            ref={progressRef}
                            className="progress-bar-fill"
                            style={{
                                transform: `scaleX(${progress >= 99 ? 1 : progress <= 0.1 ? 0 : progress / 100})`,
                            }}
                        />
                    </div>
                </div>
            )}

            {isProgressBarMulti && (
                <div className="progress-bar-wrapper">
                    {imageUrls.map((url, index) => (
                        <div className="progress-bar" key={index}>
                            <div
                                ref={(el) => {
                                    if (el) progressRefs.current[index] = el;
                                }}
                                className="progress-bar-fill"
                                style={{
                                    transform: `scaleX(${index < currentIndex ? 1 : index === currentIndex ? (progress >= 99 ? 1 : progress <= 0.1 ? 0 : progress / 100) : 0})`,
                                }}
                            />
                        </div>
                    ))}
                </div>
            )}
            {/* Navigation */}
            <div className="navigation">
                <button onClick={handlePrev}>Prev</button>
                <button onClick={handleNext}>Next</button>
            </div>
        </div>
    );
}
```


</details>

<details>
<summary>Sketch Ïú†Ìã∏ ÌÅ¥ÎûòÏä§</summary>

```typescript
// src/components/Slider/Sketch.ts
import * as THREE from "three";
import { TimelineMax, Power2 } from "gsap";

export default class Sketch {
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private material: THREE.ShaderMaterial;
    private geometry: THREE.PlaneGeometry;
    private plane: THREE.Mesh;
    private textures: THREE.Texture[] = [];
    private uniforms: any;
    private width: number;
    private height: number;
    private imageAspect: number;
    private container: HTMLElement;
    private vertex: string;
    private fragment: string;
    private time: number = 0;
    private current: number = 0;
    private isRunning = false;
    private paused = true;
    private duration: number;
    private easing: string;
    private debug: boolean;
    private settings: Record<string, any> = {};
    private gui: any;

    constructor(opts: { fragment: string; uniforms: any; duration?: number; easing?: string; debug?: boolean }) {
        this.scene = new THREE.Scene();
        this.vertex = `varying vec2 vUv;void main() {vUv = uv;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}`;
        this.fragment = opts.fragment;
        this.uniforms = opts.uniforms;
        this.renderer = new THREE.WebGLRenderer();
        this.duration = opts.duration || 1;
        this.debug = opts.debug || false;
        this.easing = opts.easing || "easeInOut";

        this.container = document.getElementById("slider")!;
        this.textures = [];

        this.width = this.container.offsetWidth;
        this.height = this.container.offsetHeight;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(this.width, this.height);
        this.renderer.setClearColor(0xeeeeee, 1);
        this.container.appendChild(this.renderer.domElement);

        this.camera = new THREE.PerspectiveCamera(70, this.width / this.height, 0.001, 1000);
        this.camera.position.set(0, 0, 2);

        this.initiate(() => {
            this.setupResize();
            this.settingsPanel();
            this.addObjects();
            this.resize();
            this.play();
        });
    }

    private initiate(cb: () => void) {
        const images = JSON.parse(this.container.getAttribute("data-images")!);
        const promises = images.map(
            (url: string, i: number) =>
                new Promise<void>((resolve) => {
                    this.textures[i] = new THREE.TextureLoader().load(url, resolve);
                })
        );

        console.log("image", images);

        Promise.all(promises).then(cb);
    }

    private setupResize() {
        window.addEventListener("resize", this.resize.bind(this));
    }

    private resize() {
        this.width = this.container.offsetWidth;
        this.height = this.container.offsetHeight;
        this.renderer.setSize(this.width, this.height);
        this.camera.aspect = this.width / this.height;

        this.imageAspect = this.textures[0].image.height / this.textures[0].image.width;
        const a1 = this.height / this.width > this.imageAspect ? (this.width / this.height) * this.imageAspect : 1;
        const a2 = this.height / this.width > this.imageAspect ? 1 : this.height / this.width / this.imageAspect;

        this.material.uniforms.resolution.value.set(this.width, this.height, a1, a2);

        const dist = this.camera.position.z;
        const height = 1;
        this.camera.fov = 2 * (180 / Math.PI) * Math.atan(height / (2 * dist));
        this.plane.scale.set(this.camera.aspect, 1);
        this.camera.updateProjectionMatrix();
    }

    private settingsPanel() {
        // transition Ï†ÑÏö© progress Ï†úÏô∏
        this.settings = {};
        if (this.debug) this.gui = new (require("dat.gui").GUI)();
        Object.keys(this.uniforms).forEach((key) => {
            if (key === "progress") return;
            this.settings[key] = this.uniforms[key].value;
            if (this.debug && this.uniforms[key].min !== undefined) {
                this.gui.add(this.settings, key, this.uniforms[key].min, this.uniforms[key].max, 0.01);
            }
        });
    }

    private addObjects() {
        this.material = new THREE.ShaderMaterial({
            extensions: { derivatives: "#extension GL_OES_standard_derivatives : enable" },
            side: THREE.DoubleSide,
            uniforms: {
                time: { value: 0 },
                progress: { value: 0 },
                border: { value: 0 },
                intensity: { value: 0 },
                scaleX: { value: 40 },
                scaleY: { value: 40 },
                transition: { value: 40 },
                swipe: { value: 0 },
                width: { value: 0 },
                radius: { value: 0 },
                texture1: { value: this.textures[0] },
                texture2: { value: this.textures[1] },
                displacement: { value: new THREE.TextureLoader().load("img/disp1.jpg") },
                resolution: { value: new THREE.Vector4() },
            },
            vertexShader: this.vertex,
            fragmentShader: this.fragment,
        });

        this.geometry = new THREE.PlaneGeometry(1, 1, 2, 2);
        this.plane = new THREE.Mesh(this.geometry, this.material);
        this.scene.add(this.plane);
    }

    private play() {
        this.paused = false;
        this.render();
    }

    public next() {
        if (this.isRunning) return;
        this.isRunning = true;
        const len = this.textures.length;
        const nextTexture = this.textures[(this.current + 1) % len];
        this.material.uniforms.texture2.value = nextTexture;
        console.log("next", this.isRunning);
        const tl = new TimelineMax();
        tl.to(this.material.uniforms.progress, this.duration, {
            value: 1,
            ease: Power2[this.easing],
            onComplete: () => {
                this.current = (this.current + 1) % len;
                this.material.uniforms.texture1.value = nextTexture;
                this.material.uniforms.progress.value = 0;
                this.isRunning = false;
            },
        });
    }

    public prev() {
        if (this.isRunning) return;
        this.isRunning = true;
        const len = this.textures.length;
        const prevIndex = (this.current - 1 + len) % len;
        const prevTexture = this.textures[prevIndex];
        this.material.uniforms.texture2.value = prevTexture;

        const tl = new TimelineMax();
        tl.to(this.material.uniforms.progress, this.duration, {
            value: 1,
            ease: Power2[this.easing],
            onComplete: () => {
                this.current = prevIndex;
                this.material.uniforms.texture1.value = prevTexture;
                this.material.uniforms.progress.value = 0;
                this.isRunning = false;
            },
        });
    }

    private render() {
        if (this.paused) return;
        this.time += 0.05;
        this.material.uniforms.time.value = this.time;

        // settingsÏóê Ìè¨Ìï®Îêú Ïú†ÎãàÌèºÎßå ÏóÖÎç∞Ïù¥Ìä∏ (progress Ï†úÏô∏)
        Object.keys(this.settings).forEach((key) => {
            if (this.material.uniforms[key] !== undefined) {
                this.material.uniforms[key].value = this.settings[key];
            }
        });

        requestAnimationFrame(this.render.bind(this));
        this.renderer.render(this.scene, this.camera);
    }
}
```


</details>

<details>
<summary>Slider Ïä§ÌÉÄÏùº</summary>

```scss
.slider-container {
  position: relative;
  width: 100%;
  height: 100vh;
  overflow: hidden;

  .slider-canvas, canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 0;
  }

  .slide-content-wrapper {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
  }

  .slide {
    width: 100%;
    height: 100%;

    .slide-bg{
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      img{
        width: 100%;
      }
    }

    .slide-content {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;

      font-size: 2rem ;
      color: #fff;
     
    }
    &.active .slide-content{
      opacity: 1;
      transition: opacity 0.5s ease-in-out 0.5s;
    }
  }

  .navigation {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    z-index: 10;
    display: flex;
    justify-content: space-between;
    transform: translateY(-50%);
    pointer-events: none;
    padding: 0 4rem;

    button {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0);
      color: white;
      border: none;
      padding: 8px 12px;
      cursor: pointer;
    }
  }

  .stop-btn {
    position: absolute;
    bottom: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 20;
    font-size: 2rem;
    color: #fff;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    padding: 10px 20px;
  }

  .progress-bar-wrapper {
    position: absolute;
    bottom: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    height: 4px;
    width: 40rem;
    z-index: 20;

    display: flex;
    gap: 1rem;
    .progress-bar{
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
    }
    .progress-bar-fill {
        width: 100%;     
        height: 100%;
        background: #fff;
        transform: scaleX(0);
        transform-origin: left;
        transition: transform 0.1s linear;
    }
  }
}
```


</details>


---


## Ïù¥ÎØ∏ÏßÄ Ìä∏ÎûúÏßÄÏÖò Ïä¨ÎùºÏù¥Îìú (+navigation)


![transitionBg.gif](https://prod-files-secure.s3.us-west-2.amazonaws.com/65a7a4f3-5212-474e-9cb7-2dc73b477f61/bb4e1aef-b574-468a-9906-997a62fab4f7/transitionBg.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466TPPVKFQU%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T081855Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEPD%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIFi5hyTRxT7CPVA4tcKohuRbW4VYQzMLjTMDqP5Ccs5QAiBMo1bHu4ayb2tZV%2F%2BudC897JsTiVJB7N%2FNbqsHaSZMVyqIBAi5%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDYzNzQyMzE4MzgwNSIMzk5BkFyi2Tm9Eu3JKtwDaE49WHAJC3ZHAgPVKXDVD%2FTA6SxS%2Fnhg3Ym%2FZnm7MMAsI7AnDkSugW3Wf3x%2Bg7kt0j72mT9EAsHYa%2FNviSWcCDF5uaijuZAyS8gLPK1bI3oMnDdEGYC4%2FFo54mSPRWSipfA3HuQEYtTWywKijLn%2FRDJZy5w3zKMjNNN%2FyUhAfhEMZ%2FfV6IeaY2UhJp0x2OdcOQCXjuJ8U59v5jsQfvWUDomhzCL9RWMxOy9Q1alm9hBKiLfvunRSmXMUpQtPft9ULw5yb2r7uZimkEkXk99AQZIygrfJAmD4TFtqSpB2QwH020J5cooBRksvZMtttANiw19sFzwZiWz8XPA6FKyYh6SN4Afp%2FQOILVaCEnl5ReVpUFbbjS9QQPiSBn%2FSXKmPvAdu7cC4Gx5WBiMsoSwYz%2BeFtWCKULPkaFQ9I8QInZwpeRWqdfMKkI%2BRUM4sosELTHom6CeVwyHMo%2F%2FwZEqgIIXXKD%2Fe0fGmm3eMLRJFazTbqAB3ObOAnfwzvwzuotTAFe7xMoJbymOwE8B1ui9TB8MzPX%2FJ13lVYXJEqhxj2N3HNdmca76VnSlK4sK1mVmYRlCCQSLHarvuu7tobQXyetZv4U6SitStoZy6AmJTjVZlNQpUvVzAliSqoXcw9YyIywY6pgGcVKqipxGphrjIK27kNEZycZMO0xOSeMG6WoOaeK9iZpVfybI1HjO1vr%2F0AR32Z8gD1m8DZANDbkZwQ2eGV1VAEQxuO8ppBumzbyHBVSWix78yVvZ2N7t9xoRVt40bU9P4K2A6LaA5Ms7TVOS6QNAndRFscwuvW0k%2Fi1xBaGFBeWO6Oh3uKvMcMLOq7AyPulgLray9t8JAt%2BRhTsDScn8Z73ro9EGK&X-Amz-Signature=18abffdf9995b4ad64d961bc303c1ba38ad67eb0c4621b3a45f33f8dc04e6231&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


### ‚óæ Ïª¥Ìè¨ÎÑåÌä∏ ÏÇ¨Ïö© ÏòàÏãú


```typescript
<Slider type="B" />
```

<details>
<summary>Slide Ïª¥Ìè¨ÎÑåÌä∏ ÏΩîÎìú</summary>

```typescript
// @/components/interaction/Slider/index.tsx

"use client";

import { useEffect, useRef } from "react";
import Sketch from "./Sketch";

type Props = {
    type: "A" | "B" | "C" | "D";
};

const sketchOptions: Record<
    "A" | "B" | "C" | "D",
    {
        fragment: string;
        uniforms: Record<string, { value: number; min?: number; max?: number; type: string }>;
        duration?: number;
        easing?: string;
        debug?: boolean;
    }
> = {
    A: {
        debug: false,
        uniforms: {
            intensity: { value: 50, type: "f", min: 1, max: 100 },
        },
        fragment: `
            uniform float time;
            uniform float progress;
            uniform float intensity;
            uniform float width;
            uniform float scaleX;
            uniform float scaleY;
            uniform float transition;
            uniform float radius;
            uniform float swipe;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform sampler2D displacement;
            uniform vec4 resolution;
            varying vec2 vUv;
            mat2 rotate(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, -s, s, c);
            }
            const float PI = 3.1415;
            const float angle1 = PI *0.25;
            const float angle2 = -PI *0.75;


            void main()	{
                vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

                vec2 uvDivided = fract(newUV*vec2(intensity,1.));


                vec2 uvDisplaced1 = newUV + rotate(3.1415926/4.)*uvDivided*progress*0.1;
                vec2 uvDisplaced2 = newUV + rotate(3.1415926/4.)*uvDivided*(1. - progress)*0.1;

                vec4 t1 = texture2D(texture1,uvDisplaced1);
                vec4 t2 = texture2D(texture2,uvDisplaced2);

                gl_FragColor = mix(t1, t2, progress);

            }

        `,
    },
    B: {
        uniforms: {
            width: { value: 0.5, min: 0, max: 10, type: "f" },
        },
        duration: 1.5,
        easing: "easeOut",
        debug: false,
        fragment: `
        uniform float time;
        uniform float progress;
        uniform sampler2D texture1;
        uniform sampler2D texture2;
        uniform vec4 resolution;

        varying vec2 vUv;
        varying vec4 vPosition;


        void main()	{
            vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
            vec2 p = newUV;
            float x = progress;
            x = smoothstep(.0,1.0,(x*2.0+p.y-1.0));
            vec4 f = mix(
                texture2D(texture1, (p-.5)*(1.-x)+.5), 
                texture2D(texture2, (p-.5)*x+.5), 
                x);
            gl_FragColor = f;
        }`,
    },
    C: {
        uniforms: {
            radius: { value: 0.9, min: 0.1, max: 2, type: "f" },
            width: { value: 0.35, min: 0, max: 1, type: "f" },
        },
        duration: 1.5,
        debug: false,
        easing: "easeOut",
        fragment: `
            uniform float time;
            uniform float progress;
            uniform float width;
            uniform float scaleX;
            uniform float scaleY;
            uniform float transition;
            uniform float radius;
            uniform float swipe;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform sampler2D displacement;
            uniform vec4 resolution;

            varying vec2 vUv;
            varying vec4 vPosition;

            float parabola( float x, float k ) {
            return pow( 4. * x * ( 1. - x ), k );
            }

            void main()	{
            vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
            vec2 p = newUV;
            vec2 start = vec2(0.5,0.5);
            vec2 aspect = resolution.wz;

            vec2 uv = newUV;
            float dt = parabola(progress, 1.);
            vec4 noise = texture2D(displacement, fract(vUv+time*0.04));
            float prog = progress*0.66 + noise.g * 0.04;
            float circ = 1. - smoothstep(-width, 0.0, radius * distance(start*aspect, uv*aspect) - prog*(1.+width));
            float intpl = pow(abs(circ), 1.);
            vec4 t1 = texture2D( texture1, (uv - 0.5) * (1.0 - intpl) + 0.5 ) ;
            vec4 t2 = texture2D( texture2, (uv - 0.5) * intpl + 0.5 );
            gl_FragColor = mix( t1, t2, intpl );
            }
        `,
    },
    D: {
        debug: false,
        uniforms: {
            intensity: { value: 0.3, type: "f", min: 0, max: 2 },
        },
        fragment: `
            uniform float time;
            uniform float progress;
            uniform float width;
            uniform float scaleX;
            uniform float scaleY;
            uniform float transition;
            uniform float radius;
            uniform float intensity;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform sampler2D displacement;
            uniform vec4 resolution;
            varying vec2 vUv;

            void main()	{
            vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

            vec4 d1 = texture2D(texture1, newUV);
            vec4 d2 = texture2D(texture2, newUV);

            float displace1 = (d1.r + d1.g + d1.b)*0.33;
            float displace2 = (d2.r + d2.g + d2.b)*0.33;
            
            vec4 t1 = texture2D(texture1, vec2(newUV.x, newUV.y + progress * (displace2 * intensity)));
            vec4 t2 = texture2D(texture2, vec2(newUV.x, newUV.y + (1.0 - progress) * (displace1 * intensity)));

            gl_FragColor = mix(t1, t2, progress);

            }
        `,
    },
};

export default function Slider({ type }: Props) {
    const sliderRef = useRef<HTMLDivElement>(null);
    const sketchRef = useRef<Sketch | null>(null);

    useEffect(() => {
        if (!sliderRef.current) return;

        const imageUrls = ["/img/testBg_01.jpg", "/img/testBg_02.jpg", "/img/testBg_03.jpg"];
        // data-images ÏÑ∏ÌåÖ
        sliderRef.current.setAttribute("data-images", JSON.stringify(imageUrls));

        console.log("[Slider] instantiate Sketch");
        // Sketch Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        sketchRef.current = new Sketch({
            fragment: sketchOptions[type].fragment,
            uniforms: sketchOptions[type].uniforms,
            duration: sketchOptions[type].duration,
            easing: sketchOptions[type].easing,
            debug: sketchOptions[type].debug,
        });
        console.log("[Slider] sketchRef:", sketchRef.current);
    }, [type]);

    const handlePrev = () => {
        console.log("[Slider] Prev clicked ‚Üí", sketchRef.current);
        sketchRef.current?.prev();
    };

    const handleNext = () => {
        console.log("[Slider] Next clicked ‚Üí", sketchRef.current);
        sketchRef.current?.next();
    };

    return (
        <div className="slider-container">
            <div id="slider" ref={sliderRef} className="slider-canvas" />
            <div className="controls">
                <button onClick={handlePrev} className="btn prev">
                    Prev
                </button>
                <button onClick={handleNext} className="btn next">
                    Next
                </button>
            </div>
        </div>
    );
}
```


</details>

<details>
<summary>Sketch Ïú†Ìã∏ ÌÅ¥ÎûòÏä§</summary>

```typescript
// src/components/interaction/Slider/Sketch.ts
import * as THREE from "three";
import { TimelineMax, Power2 } from "gsap";

export default class Sketch {
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private material: THREE.ShaderMaterial;
    private geometry: THREE.PlaneGeometry;
    private plane: THREE.Mesh;
    private textures: THREE.Texture[] = [];
    private uniforms: any;
    private width: number;
    private height: number;
    private imageAspect: number;
    private container: HTMLElement;
    private vertex: string;
    private fragment: string;
    private time: number = 0;
    private current: number = 0;
    private isRunning = false;
    private paused = true;
    private duration: number;
    private easing: string;
    private debug: boolean;
    private settings: Record<string, any> = {};
    private gui: any;

    constructor(opts: { fragment: string; uniforms: any; duration?: number; easing?: string; debug?: boolean }) {
        this.scene = new THREE.Scene();
        this.vertex = `varying vec2 vUv;void main() {vUv = uv;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}`;
        this.fragment = opts.fragment;
        this.uniforms = opts.uniforms;
        this.renderer = new THREE.WebGLRenderer();
        this.duration = opts.duration || 1;
        this.debug = opts.debug || false;
        this.easing = opts.easing || "easeInOut";

        this.container = document.getElementById("slider")!;
        this.textures = [];

        this.width = this.container.offsetWidth;
        this.height = this.container.offsetHeight;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(this.width, this.height);
        this.renderer.setClearColor(0xeeeeee, 1);
        this.container.appendChild(this.renderer.domElement);

        this.camera = new THREE.PerspectiveCamera(70, this.width / this.height, 0.001, 1000);
        this.camera.position.set(0, 0, 2);

        this.initiate(() => {
            this.setupResize();
            this.settingsPanel();
            this.addObjects();
            this.resize();
            this.play();
        });
    }

    private initiate(cb: () => void) {
        const images = JSON.parse(this.container.getAttribute("data-images")!);
        const promises = images.map(
            (url: string, i: number) =>
                new Promise<void>((resolve) => {
                    this.textures[i] = new THREE.TextureLoader().load(url, resolve);
                })
        );

        Promise.all(promises).then(cb);
    }

    private setupResize() {
        window.addEventListener("resize", this.resize.bind(this));
    }

    private resize() {
        this.width = this.container.offsetWidth;
        this.height = this.container.offsetHeight;
        this.renderer.setSize(this.width, this.height);
        this.camera.aspect = this.width / this.height;

        this.imageAspect = this.textures[0].image.height / this.textures[0].image.width;
        const a1 = this.height / this.width > this.imageAspect ? (this.width / this.height) * this.imageAspect : 1;
        const a2 = this.height / this.width > this.imageAspect ? 1 : this.height / this.width / this.imageAspect;

        this.material.uniforms.resolution.value.set(this.width, this.height, a1, a2);

        const dist = this.camera.position.z;
        const height = 1;
        this.camera.fov = 2 * (180 / Math.PI) * Math.atan(height / (2 * dist));
        this.plane.scale.set(this.camera.aspect, 1);
        this.camera.updateProjectionMatrix();
    }

    private settingsPanel() {
        // transition Ï†ÑÏö© progress Ï†úÏô∏
        this.settings = {};
        if (this.debug) this.gui = new (require("dat.gui").GUI)();
        Object.keys(this.uniforms).forEach((key) => {
            if (key === "progress") return;
            this.settings[key] = this.uniforms[key].value;
            if (this.debug && this.uniforms[key].min !== undefined) {
                this.gui.add(this.settings, key, this.uniforms[key].min, this.uniforms[key].max, 0.01);
            }
        });
    }

    private addObjects() {
        this.material = new THREE.ShaderMaterial({
            extensions: { derivatives: "#extension GL_OES_standard_derivatives : enable" },
            side: THREE.DoubleSide,
            uniforms: {
                time: { value: 0 },
                progress: { value: 0 },
                border: { value: 0 },
                intensity: { value: 0 },
                scaleX: { value: 40 },
                scaleY: { value: 40 },
                transition: { value: 40 },
                swipe: { value: 0 },
                width: { value: 0 },
                radius: { value: 0 },
                texture1: { value: this.textures[0] },
                texture2: { value: this.textures[1] },
                displacement: { value: new THREE.TextureLoader().load("img/disp1.jpg") },
                resolution: { value: new THREE.Vector4() },
            },
            vertexShader: this.vertex,
            fragmentShader: this.fragment,
        });

        this.geometry = new THREE.PlaneGeometry(1, 1, 2, 2);
        this.plane = new THREE.Mesh(this.geometry, this.material);
        this.scene.add(this.plane);
    }

    private play() {
        this.paused = false;
        this.render();
    }

    public next() {
        if (this.isRunning) return;
        this.isRunning = true;
        const len = this.textures.length;
        const nextTexture = this.textures[(this.current + 1) % len];
        this.material.uniforms.texture2.value = nextTexture;

        const tl = new TimelineMax();
        tl.to(this.material.uniforms.progress, this.duration, {
            value: 1,
            ease: Power2[this.easing],
            onComplete: () => {
                this.current = (this.current + 1) % len;
                this.material.uniforms.texture1.value = nextTexture;
                this.material.uniforms.progress.value = 0;
                this.isRunning = false;
            },
        });
    }

    public prev() {
        if (this.isRunning) return;
        this.isRunning = true;
        const len = this.textures.length;
        const prevIndex = (this.current - 1 + len) % len;
        const prevTexture = this.textures[prevIndex];
        this.material.uniforms.texture2.value = prevTexture;

        const tl = new TimelineMax();
        tl.to(this.material.uniforms.progress, this.duration, {
            value: 1,
            ease: Power2[this.easing],
            onComplete: () => {
                this.current = prevIndex;
                this.material.uniforms.texture1.value = prevTexture;
                this.material.uniforms.progress.value = 0;
                this.isRunning = false;
            },
        });
    }

    private render() {
        if (this.paused) return;
        this.time += 0.05;
        this.material.uniforms.time.value = this.time;

        // settingsÏóê Ìè¨Ìï®Îêú Ïú†ÎãàÌèºÎßå ÏóÖÎç∞Ïù¥Ìä∏ (progress Ï†úÏô∏)
        Object.keys(this.settings).forEach((key) => {
            if (this.material.uniforms[key] !== undefined) {
                this.material.uniforms[key].value = this.settings[key];
            }
        });

        requestAnimationFrame(this.render.bind(this));
        this.renderer.render(this.scene, this.camera);
    }
}
```


</details>

<details>
<summary>Slide Ïä§ÌÉÄÏùº</summary>

```scss
.slider-container {
  position: relative;
}
.slider-canvas {
  width: 100%;
  height: 100vh;
}
.controls {
  position: absolute;
  top: 50%; left: 0; right: 0;
  display: flex;
  justify-content: space-between;
  transform: translateY(-50%);
  pointer-events: none;
}
.btn {
  pointer-events: auto;
  background: rgba(255, 255, 255, 0.3);
  color: white;
  border: none;
  padding: 8px 12px;
  cursor: pointer;
}
```


</details>


---

> Ï∞∏Í≥†
>
> [bookmark](https://github.com/akella/webGLImageTransitions/)
>
>
