---
title: "NuxtLink를 쓰는 이유"
date: "2025-06-13"
tags: ["Vue"]
notionId: "211a784e-4dc2-8027-bb31-ce06e90a8b2c"
lastEditedTime: "2026-01-10T04:21:00.000Z"
---
프로젝트에서 공통으로 ripple을 적용하기 위해 `v-ripple` 디렉티브를 사용하려던 중에  **`NuxtLink`**같은 커스텀 컴포넌트에서 `v-ripple` 같은 디렉티브가 곧장 전달되지 않아서 제대로 동작하지 않는다는 것을 알게됐다.


---


## 우선, 해결방법으로는…


### ◾ `custom` + 직접 `<a>` 태그에 붙이기

- NuxtLink에 `custom` 속성으로 v-slot을 쓰면, 직접 렌더링할 `<a>`를 제어할 수 있습니다.

    ```javascript
    <template>
      <NuxtLink
        to="https://…"
        target="_blank"
        custom
        v-slot="{ navigate, href, isActive, isExactActive }"
      >
        <a
          :href="href"
          @click="navigate"
          class="quick btn"
          v-ripple
        >
          <!-- SVG 등 내부 마크업 -->
        </a>
      </NuxtLink>
    </template>
    ```


---


## 그럼에도 **`NuxtLink`**를 쓰는 이유는?


SPA(싱글 페이지 애플리케이션) 특유의 사용자 경험(UX) 최적화와 라우터 관리 편의성 때문이다.

1. **클라이언트 사이드 네비게이션**
    - 페이지 전체를 리로드하지 않고 내부 라우팅만으로 URL과 컴포넌트만 바꿔주기 때문에 전환이 빠르고 매끄럽다.
    - `<a>` 태그 클릭 시 브라우저가 서버에 새 요청을 보내는 것과 달리, NuxtLink는 Vue Router를 통해 필요한 부분만 렌더링한다.
2. **자동 프리패칭(prefetch)**
    - 화면에 보여질 때(`visibility` or `hover` 등) 미리 다음 페이지의 자바스크립트 청크를 가져온다.
    - 실제로 링크를 클릭하면 이미 로드된 상태여서 거의 즉시 보여줄 수 있어 UX가 크게 개선된다.
3. **활성 상태 관리(active class)**
    - `active-class` 또는 기본 `router-link-active` 클래스를 통해 현재 경로와 일치하는 링크에 자동으로 스타일을 입힐 수 있다.
    - 내비게이션 바에서 “어느 메뉴가 지금 선택된 상태인지”를 간단하게 표시 가능하다.
4. **동적 라우팅 & 이름 기반 라우팅 지원**
    - 객체(`:to="{ name: 'user-id', params: { id: 123 } }"`) 형태로 라우팅을 선언하면, URL 빌딩·파라미터 삽입을 수동으로 할 필요 없이 Vue Router가 처리해 준다.
    - 경로 변경 시 실수로 잘못된 URL을 입력하는 리스크도 줄어든다.
5. **SSR 친화성 & SEO**
    - Nuxt의 서버사이드 렌더링(SSR) 과정에서도 `<NuxtLink>`는 내부 링크로 정상 처리되고, 빌드 시점에 `<a href="…">` 로도 렌더링된다.
    - SEO 크롤러엔 `<a>`와 같지만, 클라이언트에선 SPA 네비게이션의 이점을 그대로 살릴 수 있다.
