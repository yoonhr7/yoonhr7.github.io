---
title: "Vue3"
date: "2025-02-18"
tags: ["Vue"]
notionId: "19ea784e-4dc2-80be-be53-f8149e37ce4d"
lastEditedTime: "2026-01-10T04:21:00.000Z"
---
## Composable


Vue 3에서 **재사용 가능한 로직**을 만들기 위한 **Composition API 함수**를 의미합니다.


### **Composable의 핵심 개념**

1. **Composition API 기반**
    - `setup()` 내부에서 사용 가능
    - `reactive()`, `ref()`, `computed()`, `watch()` 같은 API를 조합해서 로직을 관리
2. **로직 재사용 가능**
    - 여러 컴포넌트에서 동일한 기능이 필요할 때, Composable을 만들면 코드 중복을 줄일 수 있습니다.
3. **일반적으로** **`use`****라는 네이밍 규칙 사용**
    - 예: `useFetch()`, `useMouse()`, `useCounter()`

### **Composable 사용 예시**


```javascript
// composables/useCounter.js
import { ref } from 'vue';

export function useCounter() {
  const count = ref(0);

  function increment() {
    count.value++;
  }

  return { count, increment };
}
```


```javascript
<!-- MyComponent.vue -->
<script setup>
import { useCounter } from '@/composables/useCounter';

const { count, increment } = useCounter();
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="increment">+</button>
  </div>
</template>
```


→ `useCounter()`를 호출하면 `count` 상태와 `increment()` 함수가 반환됩니다.


→ 여러 컴포넌트에서 재사용할 수 있습니다.


### **Composable을 쓰면 좋은 경우**

1. **데이터 Fetching** → `useFetch()`
2. **마우스 좌표 추적** → `useMouse()`
3. **다크 모드 토글** → `useDarkMode()`
4. **웹소켓 연결 관리** → `useWebSocket()`

### **Component와 Composable 차이점**


| **항목**    | **Component**                            | **Composable**                       |
| --------- | ---------------------------------------- | ------------------------------------ |
| **목적**    | UI와 관련된 부분을 정의하고 화면에 표시                  | 로직과 상태를 정의하고 재사용 가능하게 만듦             |
| **구성**    | 템플릿(HTML), 스크립트(로직), 스타일                 | 함수형 로직 (UI 없음)                       |
| **재사용성**  | 주로 UI 부분을 재사용                            | 주로 로직을 재사용                           |
| **사용 예시** | `MyButton.vue`, `MyHeader.vue` 등 UI 컴포넌트 | `useCounter()`, `useFetch()` 등 로직 함수 |
| **상태 관리** | `data`, `computed`, `methods`로 상태와 로직 관리 | `ref()`, `reactive()`로 상태 관리         |


---


## **Composition API의 특징**


###  `setup()` 함수에서 모든 로직을 정의

- Vue 컴포넌트가 생성되기 전에 실행됩니다.
- **반환값(****`return`****)에 있는 것만 템플릿에서 사용 가능합니다.**

```plain text
vue
복사편집
<script setup>
import { ref } from 'vue';

const count = ref(0);

function increment() {
  count.value++;
}
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="increment">+</button>
  </div>
</template>
```


→ `ref(0)`을 사용해 반응형 상태를 만들고, `setup()`에서 `count`와 `increment`를 정의합니다.


→ `return` 없이 템플릿에서 직접 접근할 수 있습니다! (`<script setup>` 문법 덕분)


###  `ref()`와 `reactive()`로 반응형 데이터 선언


Vue 3에서는 `ref()`와 `reactive()`를 사용해 상태를 선언할 수 있어.


**1)** **`ref()`** **→ 단일 값 반응형 상태**


```plain text
vue
복사편집
<script setup>
import { ref } from 'vue';

const message = ref('Hello Vue 3!');
</script>

<template>
  <p>{{ message }}</p>
</template>
```


→ `ref`는 `.value`를 사용해야 합니다. (`message.value = 'New Text'`)


**2)** **`reactive()`** **→ 객체 반응형 상태**


```plain text
vue
복사편집
<script setup>
import { reactive } from 'vue';

const state = reactive({
  count: 0,
  name: 'Vue',
});
</script>

<template>
  <p>{{ state.count }}</p>
  <p>{{ state.name }}</p>
</template>
```


→ `reactive`는 `.value`가 필요 없습니다. (`state.count = 1`처럼 직접 변경 가능)


### 3. `computed()`와 `watch()`로 상태 관리


**1)** **`computed()`** **→ 계산된 값**


```plain text
vue
복사편집
<script setup>
import { ref, computed } from 'vue';

const count = ref(5);
const doubleCount = computed(() => count.value * 2);
</script>

<template>
  <p>Original: {{ count }}</p>
  <p>Doubled: {{ doubleCount }}</p>
</template>
```


→ `computed()`는 `ref()`처럼 반응형이고, `count.value`가 변하면 자동으로 업데이트됩니다.


**2)** **`watch()`** **→ 특정 상태 변경 감지**


```plain text
vue
복사편집
<script setup>
import { ref, watch } from 'vue';

const count = ref(0);

watch(count, (newValue, oldValue) => {
  console.log(`count changed from ${oldValue} to ${newValue}`);
});
</script>

<template>
  <button @click="count++">Increase</button>
</template>
```


→ `count` 값이 변할 때마다 `watch()`가 실행됩니다.


###  `provide()`와 `inject()`로 상태 공유


Composition API에서도 **전역적으로 상태를 공유할 수 있습니다.**


**1)** **`provide()`** **→ 부모에서 데이터 제공**


```plain text
vue
복사편집
<script setup>
import { ref, provide } from 'vue';

const theme = ref('dark');
provide('theme', theme);
</script>

<template>
  <slot></slot>
</template>
```


**2)** **`inject()`** **→ 자식에서 데이터 사용**


```plain text
vue
복사편집
<script setup>
import { inject } from 'vue';

const theme = inject('theme');
</script>

<template>
  <p>Current theme: {{ theme }}</p>
</template>
```


✔️ `provide()`를 사용하면 하위 컴포넌트에서 `inject()`로 값을 받아올 수 있습니다.


###  **Composition API를 쓰는 이유**

1. **로직을 모듈화할 수 있음** → Composable(`useCounter`, `useFetch` 등)로 분리 가능
2. **코드 가독성이 높아짐** → 관련된 로직을 한곳에 모아서 관리 가능
3. **Typescript 사용이 쉬움** → 함수 기반이므로 타입 추론이 편리
4. **Vue 3의 공식 권장 방식** → 더 많은 기능과 확장성을 제공

→  **언제 Composition API를 써야 할까?**

- **작은 프로젝트** → Options API도 충분히 OK
- **컴포넌트가 복잡한 프로젝트** → Composition API 추천
- **반응형 상태를 재사용하고 싶을 때** → Composition API 필수

---

