---
title: "React 시작하기"
date: "2025-06-30"
notionId: "222a784e-4dc2-8099-ab56-e0fead756ff4"
lastEditedTime: "2026-01-10T04:21:00.000Z"
---
<aside data-icon="💡">

React를 시작하면서 미리 알면 좋을 것들을 정리했습니다.

</aside>


## 1. React 의 hook 들


| Hook 이름            | 용도 / 기능 설명                                       | 사용 예시 / 특징                                                 |
| ------------------ | ------------------------------------------------ | ---------------------------------------------------------- |
| `useState`         | 상태(state)를 함수형 컴포넌트에서 사용                         | `const [count, setCount] = useState(0)`                    |
| `useEffect`        | 사이드 이펙트 처리 (마운트, 업데이트, 언마운트 시 동작)                | API 호출, 이벤트 리스너 등록/해제 등                                    |
| `useRef`           | DOM 참조 또는 값 기억 (리렌더링 불필요한 값 저장)                  | `ref.current`, 포커스 이동, 이전 값 저장 등                           |
| `useMemo`          | 계산 결과를 메모이징하여 불필요한 재계산 방지                        | `const result = useMemo(() => calc(), [a])`                |
| `useCallback`      | 함수 자체를 메모이징 (불필요한 함수 재생성 방지)                     | 자식 컴포넌트에 콜백 props 넘길 때 사용                                  |
| `useContext`       | 전역 데이터(Theme, 로그인 정보 등)를 어디서든 가져다 쓸 수 있음         | `const value = useContext(MyContext)`                      |
| `useReducer`       | 복잡한 상태 변경 로직을 관리 (Redux-like)                    | `const [state, dispatch] = useReducer(reducer, initState)` |
| `useLayoutEffect`  | DOM이 그려지기 **직전**에 실행됨 (레이아웃 측정 등에서 사용)           | `useEffect`와 유사하나 **동기적**으로 실행됨                            |
| `useId`            | 고유한 ID 생성 (접근성이나 label-for 등에서 유용)               | React 18+ 전용 – SSR과의 호환도 고려됨                               |
| `useTransition`    | 사용자와의 상호작용을 **긴 처리와 분리**해서 자연스럽게 만들기 (React 18+) | `startTransition(() => setState(...))`                     |
| `useDeferredValue` | 값 변경을 지연시켜 성능 개선 (입력창 등 빠른 UI 응답에 유리)            | `const deferredValue = useDeferredValue(inputValue)`       |


## 2. JSX 문법에서 자주 쓰는 React 특유의 방식


| 기능/패턴            | React 방식 (JSX 내 사용)                                       | 설명                                      |
| ---------------- | --------------------------------------------------------- | --------------------------------------- |
| **클래스 지정**       | `className="box"`                                         | HTML의 `class` → JSX에선 `className`       |
| **인라인 스타일**      | `style={{ color: 'red', fontSize: '20px' }}`              | 객체 형태로 작성, camelCase 속성명                |
| **반복 렌더링 (for)** | `{items.map((item, i) => <li key={i}>{item}</li>)}`       | `map()`을 사용                             |
| **조건 렌더링 (if)**  | `{isActive && <div>활성</div>}` or `{isOn ? <A /> : <B />}` | JSX에서는 `if` 대신 삼항연산자나 `&&` 사용           |
| **이벤트 핸들링**      | `onClick={() => alert('눌렀어요!')}`                          | 이벤트명도 camelCase (`onclick` → `onClick`) |
| **props 전달**     | `<MyComponent title="제목" count={5} />`                    | 문자열은 `"text"`, 숫자/변수/함수는 `{}` 안에        |
| **children 사용**  | `<Wrapper>내용</Wrapper>`                                   | 컴포넌트의 중첩 요소는 `props.children`으로 받음      |


### 2-1. 반복(for)처리 예시


```typescript
const items = ["사과", "바나나", "오렌지"];

return (
  <ul>
    {items.map((fruit, idx) => (
      <li key={idx}>{fruit}</li>
    ))}
  </ul>
);
```


### 2-2. 조건문(if) 처리 예시


```typescript
{isLogin && <p>환영합니다!</p>}
{loading ? <LoadingSpinner /> : <Content />}
```


### 2-3. 클래스 명 처리 예시


```typescript
// 조건에 따라 클래스 다르게 주기
<div className={isActive ? "box active" : "box"}>내용</div>

// 여러 조건 조합
<div className={`box ${isActive ? "active" : ""} ${isDark ? "dark" : ""}`} />
```


### 2-4. 인라인 스타일  처리 예시


```typescript
<div style={{ backgroundColor: "lightblue", padding: "1rem" }}>
  스타일 인라인!
</div>
```

